// Code generated by git.sr.ht/~nelsam/hel. DO NOT EDIT.
//
// This file contains mocks generated by hel. Do not edit this code by
// hand unless you *really* know what you're doing. Expect any changes
// made manually to be overwritten the next time hel regenerates this
// file.

package onpar_test

import (
	"testing"
	"time"

	"git.sr.ht/~nelsam/hel/vegr"
	"git.sr.ht/~nelsam/hel/vegr/ret"
)

var (
	_ = vegr.EnforceVersion(6 - vegr.MinVersion)
	_ = vegr.EnforceVersion(vegr.MaxVersion - 6)
)

type mockTestRunner struct {
	t         vegr.T
	timeout   time.Duration
	RunCalled chan bool
	RunInput  struct {
		Name chan string
		Fn   chan func(*testing.T)
	}
	RunOutput struct {
		MockReturnBlocker ret.Blocker
		MockPanicker      ret.Panicker
		Ret0              chan bool
	}
	FailedCalled chan bool
	FailedOutput struct {
		MockReturnBlocker ret.Blocker
		MockPanicker      ret.Panicker
		Ret0              chan bool
	}
	CleanupCalled chan bool
	CleanupInput  struct {
		Arg0 chan func()
	}
	CleanupOutput struct {
		MockReturnBlocker ret.Blocker
		MockPanicker      ret.Panicker
	}
}

func newMockTestRunner(t vegr.T, timeout time.Duration) *mockTestRunner {
	m := &mockTestRunner{t: t, timeout: timeout}
	m.RunCalled = make(chan bool, 100)
	m.RunInput.Name = make(chan string, 100)
	m.RunInput.Fn = make(chan func(*testing.T), 100)
	m.RunOutput.MockReturnBlocker = vegr.BlockChan()
	m.RunOutput.MockPanicker = make(ret.Panicker, 100)
	m.RunOutput.Ret0 = make(chan bool, 100)
	m.FailedCalled = make(chan bool, 100)
	m.FailedOutput.MockReturnBlocker = vegr.BlockChan()
	m.FailedOutput.MockPanicker = make(ret.Panicker, 100)
	m.FailedOutput.Ret0 = make(chan bool, 100)
	m.CleanupCalled = make(chan bool, 100)
	m.CleanupInput.Arg0 = make(chan func(), 100)
	m.CleanupOutput.MockReturnBlocker = vegr.BlockChan()
	m.CleanupOutput.MockPanicker = make(ret.Panicker, 100)
	return m
}
func (m *mockTestRunner) Run(name string, fn func(*testing.T)) (ret0 bool) {
	m.t.Helper()
	m.RunCalled <- true
	m.RunInput.Name <- name
	m.RunInput.Fn <- fn
	vegr.PopulateReturns(m.t, "Run", m.timeout, m.RunOutput, &ret0)
	return ret0
}
func (m *mockTestRunner) Failed() (ret0 bool) {
	m.t.Helper()
	m.FailedCalled <- true
	vegr.PopulateReturns(m.t, "Failed", m.timeout, m.FailedOutput, &ret0)
	return ret0
}
func (m *mockTestRunner) Cleanup(arg0 func()) {
	m.t.Helper()
	m.CleanupCalled <- true
	m.CleanupInput.Arg0 <- arg0
	vegr.PopulateReturns(m.t, "Cleanup", m.timeout, m.CleanupOutput)
}
